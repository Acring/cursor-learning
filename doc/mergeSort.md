# 归并排序 (Merge Sort)

## 基本概述和原理

归并排序是一种经典的分治算法，其基本思想是：
1. 分解：将待排序数组递归地分成两个规模大致相等的子数组
2. 解决：递归地对两个子数组进行排序
3. 合并：将两个已排序的子数组合并成一个有序数组

## 性能特征分析

### 时间复杂度
- 最好情况：O(n log n)
- 最坏情况：O(n log n)
- 平均情况：O(n log n)

归并排序的时间复杂度非常稳定，无论输入数据的分布如何，都能保持 O(n log n) 的时间复杂度。

### 空间复杂度
- O(n)：需要额外的数组空间来存储合并过程中的临时数据

## 代码实现关键点

1. 递归分割
   - 使用 `Math.floor(arr.length / 2)` 将数组平均分成两部分
   - 递归处理直到子数组长度为 1 或 0

2. 合并过程
   - 使用双指针技术比较和合并两个有序数组
   - 需要额外的数组空间存储合并结果
   - 处理剩余元素的拼接

3. 泛型支持
   - 通过 TypeScript 的泛型实现对不同数据类型的支持
   - 自定义比较函数使算法更灵活

## 使用示例

```typescript
// 基本数字数组排序
const numbers = [64, 34, 25, 12, 22, 11, 90];
console.log(mergeSort(numbers)); // [11, 12, 22, 25, 34, 64, 90]

// 字符串数组排序
const strings = ['banana', 'apple', 'orange', 'grape'];
console.log(mergeSort(strings)); // ['apple', 'banana', 'grape', 'orange']

// 对象数组排序（使用自定义比较函数）
const objects = [
    { value: 5 },
    { value: 3 },
    { value: 7 }
];
console.log(mergeSort(objects, (a, b) => a.value - b.value));
// [{ value: 3 }, { value: 5 }, { value: 7 }]
```

## 优化思路

1. 小规模数组优化
   - 当子数组规模较小时（如长度小于 10），可以使用插入排序
   - 这样可以减少递归调用的开销

2. 内存优化
   - 可以使用原地归并排序算法减少空间使用
   - 但这样会增加时间复杂度，且实现更复杂

3. 并行化
   - 可以利用多线程对大规模数据进行并行归并排序
   - 适用于大数据量场景

## 适用场景

1. 需要稳定排序的场景
2. 数据量较大且内存充足的情况
3. 对排序性能稳定性要求高的场景
4. 外部排序（处理无法一次性加载到内存的大规模数据）

## 注意事项

1. 空间开销
   - 需要额外的 O(n) 空间，不适合内存受限的场景
   - 对于大数据量，需要考虑内存使用情况

2. 递归深度
   - 递归实现可能导致栈溢出
   - 可以考虑使用迭代方式实现

3. 性能考虑
   - 对于小规模数据，可能不如简单的排序算法（如插入排序）
   - 需要根据实际场景选择是否使用优化版本 