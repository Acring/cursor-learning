# 二分查找算法

## 基本概述和原理

二分查找（Binary Search）是一种高效的查找算法，用于在**有序数组**中查找特定元素。其核心思想是：
1. 将查找范围分成两半
2. 将目标值与中间元素比较
3. 根据比较结果，在左半部分或右半部分继续查找
4. 重复以上步骤直到找到目标值或确定目标值不存在

## 性能特征分析

### 时间复杂度
- 平均情况：O(log n)
- 最坏情况：O(log n) - 当目标值在数组的最左端或最右端时
- 最好情况：O(1) - 当目标值恰好在数组中间时

### 空间复杂度
- O(1) - 只需要几个变量来存储左右边界和中间位置

## 代码实现的关键点解析

1. **边界处理**
   - 使用左右指针（left 和 right）来标记当前的查找范围
   - 循环条件是 left <= right，确保能处理边界情况
   - 中间位置计算使用 Math.floor((left + right) / 2) 避免整数溢出

2. **比较函数**
   - 提供默认的比较函数，支持基本类型的比较
   - 允许传入自定义比较函数，增加灵活性
   - 比较函数返回值：小于0表示在左边，等于0表示找到，大于0表示在右边

3. **泛型支持**
   - 使用 TypeScript 泛型使算法可以处理任意类型的有序数组
   - 通过比较函数接口确保类型安全

## 使用示例

```typescript
// 基本数字数组查找
const numbers = [1, 3, 5, 7, 9, 11, 13, 15];
binarySearch(numbers, 7);  // 返回 3

// 字符串数组查找
const strings = ['apple', 'banana', 'orange', 'pear'];
binarySearch(strings, 'orange'); // 返回 2

// 自定义对象查找
interface Person {
    age: number;
    name: string;
}
const people: Person[] = [
    { age: 20, name: 'Alice' },
    { age: 25, name: 'Bob' },
    { age: 30, name: 'Charlie' }
];
const compareByAge = (a: Person, b: Person) => a.age - b.age;
binarySearch(people, { age: 25, name: 'Bob' }, compareByAge); // 返回 1
```

## 优化思路

1. **防止整数溢出**
   - 计算中间位置时可以使用 left + Math.floor((right - left) / 2)
   - 这种方式可以避免 left + right 可能导致的整数溢出

2. **递归实现**
   - 可以改写为递归版本，使代码更简洁
   - 但会增加空间复杂度到 O(log n)

3. **查找边界**
   - 可以扩展算法以查找第一个或最后一个匹配的元素
   - 对于有重复元素的数组很有用

## 适用场景

1. 在大型有序数组中快速查找元素
2. 需要高效查找且数据已经排序的情况
3. 数据量较大但内存限制不严格的场景
4. 查找频繁但修改较少的数据集

## 需要注意的事项

1. **前提条件**
   - 数组必须是有序的，这是使用二分查找的前提
   - 如果数组未排序，需要先进行排序（可能得不偿失）

2. **边界条件**
   - 注意处理数组为空的情况
   - 注意处理目标值不在数组范围内的情况

3. **比较函数**
   - 自定义比较函数必须保持一致性
   - 比较结果应该符合传递性

4. **性能考虑**
   - 对于小规模数据，线性查找可能更快
   - 如果数据频繁变动，维护有序性的成本可能过高 